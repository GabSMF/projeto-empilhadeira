#include <Arduino.h>

// --------------------------- PINOS ---------------------------
// Motor 1 (Esquerdo)
#define IN1_L 22
#define IN2_L 23
#define EN_L 18
#define ENC_L 26

// Motor 2 (Direito)
#define IN1_R 19
#define IN2_R 21
#define EN_R 17
#define ENC_R 25

// Motor Empilhadeira
#define IN1_LIFT 33
#define IN2_LIFT 32
#define EN_LIFT 4

// --------------------------- ENCODER ---------------------------
const float PPR = 64.0;

// Esquerdo
volatile unsigned long pulseL = 0;
volatile unsigned long lastL = 0;

// Direito
volatile unsigned long pulseR = 0;
volatile unsigned long lastR = 0;

const int MIN_PULSE_WIDTH = 500;

// ---------------------- TABELAS DE CALIBRAÇÃO ------------------
float rpmTable[] = {0,   207, 295, 375, 445, 505, 560, 608, 645, 680, 713,
                    735, 755, 776, 793, 808, 830, 843, 854, 865, 875, 910};

int pwmTable[] = {0,   60,  70,  80,  90,  100, 110, 120, 130, 140, 150,
                  160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 255};

const int tableSize = sizeof(rpmTable) / sizeof(rpmTable[0]);

// ---------------------- FILTRO MÉDIA MÓVEL ---------------------
const int MOV = 20;
int pwm_atualR = 0;
int pwm_atualL = 0;

// Esquerdo
float movL[MOV];
int idxL = 0;
float sumL = 0;
float rpmL = 0;

// Direito
float movR[MOV];
int idxR = 0;
float sumR = 0;
float rpmR = 0;

// --------------------------- PID ----------------------------
float Kp = 2.0, Ki = 0.5, Kd = 0.01;

float eL = 0, iL = 0, dL = 0, lastEL = 0;
float eR = 0, iR = 0, dR = 0, lastER = 0;

float outL = 0;
float outR = 0;

long prevTime = 0;
long sampleInterval = 40;

// ----------------------- RAMPA ------------------------
float targetRPM_L = 0;
float targetRPM_R = 0;
float rampRPM_L = 0;
float rampRPM_R = 0;
float acceleration = 10;
const float BASE_RPM = 150.0; // Velocidade padrao para os movimentos

// --------------------------- ISR ---------------------------
void readL() {
  unsigned long now = micros();
  if (now - lastL > MIN_PULSE_WIDTH) {
    pulseL++;
    lastL = now;
  }
}

void readR() {
  unsigned long now = micros();
  if (now - lastR > MIN_PULSE_WIDTH) {
    pulseR++;
    lastR = now;
  }
}

// --------------------------- SETUP ---------------------------
void setup() {
  Serial.begin(115200);

  pinMode(IN1_L, OUTPUT);
  pinMode(IN2_L, OUTPUT);
  pinMode(EN_L, OUTPUT);
  pinMode(ENC_L, INPUT_PULLUP);

  pinMode(IN1_R, OUTPUT);
  pinMode(IN2_R, OUTPUT);
  pinMode(EN_R, OUTPUT);
  pinMode(ENC_R, INPUT_PULLUP);

  pinMode(IN1_LIFT, OUTPUT);
  pinMode(IN2_LIFT, OUTPUT);
  pinMode(EN_LIFT, OUTPUT);

  attachInterrupt(digitalPinToInterrupt(ENC_L), readL, CHANGE);
  attachInterrupt(digitalPinToInterrupt(ENC_R), readR, CHANGE);

  for (int i = 0; i < MOV; i++) {
    movL[i] = 0;
    movR[i] = 0;
  }

  prevTime = millis();

  Serial.println(
      "Sistema iniciado — Controle Direcional (F, B, L, R, S, U, D)");
}

// -------------------------- FUNÇÃO PWM --------------------------
int rpmToPwm(float rpmTarget) {
  float absRPM = abs(rpmTarget);

  if (absRPM <= rpmTable[0])
    return 0;

  if (absRPM >= rpmTable[tableSize - 1]) {
    int maxPWM = pwmTable[tableSize - 1];
    return (rpmTarget > 0) ? maxPWM : -maxPWM;
  }

  for (int i = 0; i < tableSize - 1; i++) {
    if (absRPM >= rpmTable[i] && absRPM <= rpmTable[i + 1]) {
      float rR = rpmTable[i + 1] - rpmTable[i];
      float rP = pwmTable[i + 1] - pwmTable[i];
      float p = (absRPM - rpmTable[i]) / rR;
      int pwm = pwmTable[i] + (rP * p);
      return (rpmTarget > 0) ? pwm : -pwm;
    }
  }
  return 0;
}

// --------------------- CONTROLE DO MOTOR ---------------------
void motorL(int pwm) {
  pwm = constrain(pwm, -255, 255);
  pwm_atualL = pwm;
  if (pwm >= 0) {
    digitalWrite(IN1_L, LOW);
    digitalWrite(IN2_L, HIGH);
    analogWrite(EN_L, pwm);
  } else {
    digitalWrite(IN1_L, HIGH);
    digitalWrite(IN2_L, LOW);
    analogWrite(EN_L, -pwm);
  }
}

void motorR(int pwm) {
  pwm = constrain(pwm, -255, 255);
  pwm_atualR = pwm;
  if (pwm >= 0) {
    digitalWrite(IN1_R, LOW);
    digitalWrite(IN2_R, HIGH);
    analogWrite(EN_R, pwm);
  } else {
    digitalWrite(IN1_R, HIGH);
    digitalWrite(IN2_R, LOW);
    analogWrite(EN_R, -pwm);
  }
}

void motorLift(int pwm) {
  pwm = constrain(pwm, -255, 255);
  if (pwm >= 0) {
    digitalWrite(IN1_LIFT, LOW);
    digitalWrite(IN2_LIFT, HIGH);
    analogWrite(EN_LIFT, pwm);
  } else {
    digitalWrite(IN1_LIFT, HIGH);
    digitalWrite(IN2_LIFT, LOW);
    analogWrite(EN_LIFT, -pwm);
  }
}

// --------------------------- LOOP ---------------------------
void loop() {

  // COMANDO SERIAL
  if (Serial.available()) {
    char cmd = Serial.read();

    // Ignora caracteres de nova linha ou retorno de carro
    if (cmd != '\n' && cmd != '\r') {
      switch (toupper(cmd)) {
      case 'F': // Frente
        targetRPM_L = BASE_RPM;
        targetRPM_R = BASE_RPM;
        Serial.println("Comando: FRENTE");
        break;
      case 'B': // Tras
        targetRPM_L = -BASE_RPM;
        targetRPM_R = -BASE_RPM;
        Serial.println("Comando: TRAS");
        break;
      case 'L': // Esquerda (Giro no eixo)
        targetRPM_L = 0;
        targetRPM_R = BASE_RPM;
        Serial.println("Comando: ESQUERDA");
        break;
      case 'R': // Direita (Giro no eixo)
        targetRPM_L = BASE_RPM;
        targetRPM_R = 0;
        Serial.println("Comando: DIREITA");
        break;
      case 'S': // Parar
        targetRPM_L = 0;
        targetRPM_R = 0;
        rampRPM_L = 0;
        rampRPM_R = 0;
        iL = 0;
        iR = 0;
        motorLift(0);
        Serial.println("Comando: PARAR");
        break;
      case 'U': // Subir
        motorLift(255);
        Serial.println("Comando: SUBIR");
        break;
      case 'D': // Descer
        motorLift(-255);
        Serial.println("Comando: DESCER");
        break;
      default:
        // Opcional: Implementar ajuste fino de velocidade ou ignorar
        break;
      }
    }
  }

  unsigned long now = millis();

  if (now - prevTime >= sampleInterval) {

    // ----- CALCULA RPM ------
    long dt = now - prevTime;

    noInterrupts();
    unsigned long pL = pulseL;
    pulseL = 0;
    unsigned long pR = pulseR;
    pulseR = 0;
    interrupts();

    float instL = ((float)pL / PPR) * (60000.0 / dt);
    float instR = ((float)pR / PPR) * (60000.0 / dt);

    // ----- MÉDIA MÓVEL ------
    sumL -= movL[idxL];
    movL[idxL] = instL;
    sumL += instL;
    idxL = (idxL + 1) % MOV;
    rpmL = sumL / MOV;

    sumR -= movR[idxR];
    movR[idxR] = instR;
    sumR += instR;
    idxR = (idxR + 1) % MOV;
    rpmR = sumR / MOV;

    // ----- RAMPA ESQUERDA ------
    float diffL = targetRPM_L - rampRPM_L;
    if (abs(diffL) > acceleration)
      rampRPM_L += (diffL > 0 ? acceleration : -acceleration);
    else
      rampRPM_L = targetRPM_L;

    // ----- RAMPA DIREITA ------
    float diffR = targetRPM_R - rampRPM_R;
    if (abs(diffR) > acceleration)
      rampRPM_R += (diffR > 0 ? acceleration : -acceleration);
    else
      rampRPM_R = targetRPM_R;

    // ----- FEEDFORWARD ------
    int ffL = rpmToPwm(rampRPM_L);
    int ffR = rpmToPwm(rampRPM_R);

    // ----- PID ESQUERDO ------
    eL = rampRPM_L - rpmL;
    iL += eL * (dt / 1000.0);
    dL = (eL - lastEL) / (dt / 1000.0);
    outL = Kp * eL + Ki * iL + Kd * dL + ffL;
    lastEL = eL;

    // ----- PID DIREITO ------
    eR = rampRPM_R - rpmR;
    iR += eR * (dt / 1000.0);
    dR = (eR - lastER) / (dt / 1000.0);
    outR = Kp * eR + Ki * iR + Kd * dR + ffR;
    lastER = eR;

    // ----- APLICA PWM ------
    motorL(outL);
    motorR(outR);

    // MONITOR SERIAL
    // Exibe apenas se houver movimento ou comando recente para nao poluir
    // demais, ou mantem continuo para debug. Mantendo continuo como no
    // original.
    Serial.print("T_L=");
    Serial.print(targetRPM_L);
    Serial.print(" T_R=");
    Serial.print(targetRPM_R);
    Serial.print(" R_L=");
    Serial.print(rpmL);
    Serial.print(" R_R=");
    Serial.println(rpmR);
    Serial.print(" out_L=");
    Serial.print(pwm_atualL);
    Serial.print(" out_R=");
    Serial.println(pwm_atualR);

    prevTime = now;
  }
}
