// --- Configurações Gerais ---
#define DIAMETRO 50
#define DENTES 32
#define PULSOS_POR_ROT 34.0f
#define t_dl 200 // Tempo de amostragem (ms)
#define PI 3.14159

// --- MOTOR 1 (Digamos, Esquerdo) ---
#define ENC_PIN_1   2  // Interrupt
#define PIN_IN1     10  // MUDOU (Era 5) - Direção A
#define PIN_IN2     11  // MUDOU (Era 6) - Direção B
#define PIN_PWM_1   5  // MUDOU (Era 2, pois o 2 agora é encoder)

// --- MOTOR 2 (Digamos, Direito) ---
#define ENC_PIN_2   3  // Interrupt (Pino 2 é obrigatório para interrupt no Uno)
#define PIN_IN3     12 // Direção A
#define PIN_IN4     13 // Direção B
#define PIN_PWM_2   6  // PWM

// --- Variáveis Globais ---
volatile long encoder1 = 0;
volatile long encoder2 = 0; // Novo encoder

long ant_encoder1 = 0;
long ant_encoder2 = 0;

unsigned long t_anterior = 0;

// --- Parâmetros de Controle ---
// Você pode ajustar Kp diferente para cada motor se eles forem fisicamente muito diferentes
float Kp1 = 1.5; 
float Kp2 = 1.5; 

float setpoint_rpm1 = 0;
float setpoint_rpm2 = 0;

// Variáveis auxiliares de estado
float sinal_controle1 = 0;
float sinal_controle2 = 0;

// --- Rotinas de Interrupção ---
void incrementa_encoder1(){
  encoder1++; 
  }
void incrementa_encoder2() { 
  encoder2++; 
  }

// --- Função Genérica para Acionar Motor ---
// Aceita os pinos como parâmetro para servir aos dois motores
void acionar_motor_generico(int pino_in_a, int pino_in_b, int pino_pwm, int acao) {
  
  // Saturação do PWM (-255 a 255)
  if (acao > 255) acao = 255;
  if (acao < -255) acao = -255;

  if (acao > 0) {
    // Frente
    digitalWrite(pino_in_a, HIGH);
    digitalWrite(pino_in_b, LOW);
    analogWrite(pino_pwm, acao);
  } 
  else if (acao < 0) {
    // Trás
    digitalWrite(pino_in_a, LOW);
    digitalWrite(pino_in_b, HIGH);
    analogWrite(pino_pwm, abs(acao));
  } 
  else {
    // Parar
    digitalWrite(pino_in_a, LOW);
    digitalWrite(pino_in_b, LOW);
    analogWrite(pino_pwm, 0);
  }
}

void setup() {
  Serial.begin(9600);

  // Configuração Motor 1
  pinMode(ENC_PIN_1, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENC_PIN_1), incrementa_encoder1, RISING);
  pinMode(PIN_IN1, OUTPUT);
  pinMode(PIN_IN2, OUTPUT);
  pinMode(PIN_PWM_1, OUTPUT);

  // Configuração Motor 2
  pinMode(ENC_PIN_2, INPUT);
  attachInterrupt(digitalPinToInterrupt(ENC_PIN_2), incrementa_encoder2, RISING);
  pinMode(PIN_IN3, OUTPUT);
  pinMode(PIN_IN4, OUTPUT);
  pinMode(PIN_PWM_2, OUTPUT);

  t_anterior = millis();

  // --- DEFINA A VELOCIDADE AQUI ---
  // Para o robô andar reto, coloque valores iguais.
  // Se um motor for mais "preso" que o outro, o controle P tentará compensar.
  setpoint_rpm1 = 100; 
  setpoint_rpm2 = 100; 
}

void loop() {
  if (millis() - t_anterior >= t_dl) {
    
    // --- CÁLCULOS MOTOR 1 ---
    long delta1 = encoder1 - ant_encoder1;
    ant_encoder1 = encoder1;
    float rpm_raw1 = (delta1 / PULSOS_POR_ROT) * (60000.0 / t_dl);
    
    // Ajuste de sinal (direção)
    float rpm_atual1 = (sinal_controle1 < 0) ? -rpm_raw1 : rpm_raw1;
    
    // Controle P Motor 1
    float erro1 = setpoint_rpm1 - rpm_atual1;
    sinal_controle1 = Kp1 * erro1;

    // --- CÁLCULOS MOTOR 2 ---
    long delta2 = encoder2 - ant_encoder2;
    ant_encoder2 = encoder2;
    float rpm_raw2 = (delta2 / PULSOS_POR_ROT) * (60000.0 / t_dl);
    
    // Ajuste de sinal (direção)
    float rpm_atual2 = (sinal_controle2 < 0) ? -rpm_raw2 : rpm_raw2;

    // Controle P Motor 2
    float erro2 = setpoint_rpm2 - rpm_atual2;
    sinal_controle2 = Kp2 * erro2;

    // --- APLICAÇÃO NOS MOTORES ---
    acionar_motor_generico(PIN_IN1, PIN_IN2, PIN_PWM_1, (int)sinal_controle1);
    acionar_motor_generico(PIN_IN3, PIN_IN4, PIN_PWM_2, (int)sinal_controle2);

    t_anterior = millis();

    // Debug: Visualizar ambos os motores no Serial Plotter
    // Formato: "Rpm1:valor Rpm2:valor Setpoint:valor"
    Serial.print("RPM1:");
    Serial.print(rpm_atual1);
    Serial.print(" RPM2:");
    Serial.print(rpm_atual2);
    Serial.print(" Setpoint:");
    Serial.println(setpoint_rpm1); // Assumindo setpoints iguais para o gráfico
  }
}
