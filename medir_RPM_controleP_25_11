// -----------------------------
// CONFIGURAÇÕES
// -----------------------------
#define DIAMETRO 50
#define ENCODER_PIN_E 2
#define ENCODER_PIN_D 3
#define PULSOS_POR_ROT 34.0f
#define t_dl 200        // Tempo de amostragem em ms // mudar para 20 ms
#define PI 3.14159

// Antibounce (µs)
const unsigned long MIN_PULSE_WIDTH = 500;

// -----------------------------
// PINOS DOS MOTORES 
// Motor ESQUERDO
// -----------------------------
#define IN1_E 12
#define IN2_E 13
#define PWM_E 6

// -----------------------------
// Motor DIREITO 
// -----------------------------
#define IN1_D 8
#define IN2_D 9
#define PWM_D 5

// -----------------------------
// VARIÁVEIS DO ENCODER
// -----------------------------
volatile long encoderE = 0;
volatile long encoderD = 0;

long ant_encoderE = 0;
long ant_encoderD = 0;

volatile unsigned long lastIsrTimeE = 0;
volatile unsigned long lastIsrTimeD = 0;

// -----------------------------
// VARIÁVEIS DE CONTROLE
// -----------------------------
float rpmE = 0;
float rpmD = 0;

float set_rpmE = 120;   // Setpoint roda esquerda
float set_rpmD = 120;   // Setpoint roda direita

float Kp = 32.5;

float erroE = 0;
float erroD = 0;

float sinalE = 0;
float sinalD = 0;

unsigned long t_anterior = 0;

// -----------------------------
// INTERRUPÇÕES COM ANTIBOUNCE
// -----------------------------
void encoderE_ISR() {

  encoderE++;

}

void encoderD_ISR() {
  unsigned long now = micros();
  if (now - lastIsrTimeD > MIN_PULSE_WIDTH) {
    encoderD++;
    lastIsrTimeD = now;
  }
}


// -----------------------------
// FUNÇÃO PARA MOVER MOTOR
// -----------------------------
void acionar_motor(int pwm, int IN1, int IN2, int PWM_PIN) {

  if (pwm > 255) pwm = 255;
  if (pwm < -255) pwm = -255;

  if (pwm > 0) {
    digitalWrite(IN1, HIGH);
    digitalWrite(IN2, LOW);
    analogWrite(PWM_PIN, pwm);
  }
  else if (pwm < 0) {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, HIGH);
    analogWrite(PWM_PIN, abs(pwm));
  }
  else {
    digitalWrite(IN1, LOW);
    digitalWrite(IN2, LOW);
    analogWrite(PWM_PIN, 0);
  }
}

// -----------------------------
// SETUP
// -----------------------------
void setup() {
  Serial.begin(9600);

  pinMode(ENCODER_PIN_E, INPUT_PULLUP);
  pinMode(ENCODER_PIN_D, INPUT_PULLUP);

  attachInterrupt(digitalPinToInterrupt(ENCODER_PIN_E), encoderE_ISR, RISING);
  attachInterrupt(digitalPinToInterrupt(ENCODER_PIN_D), encoderD_ISR, RISING);

  pinMode(IN1_E, OUTPUT);
  pinMode(IN2_E, OUTPUT);
  pinMode(PWM_E, OUTPUT);

  pinMode(IN1_D, OUTPUT);
  pinMode(IN2_D, OUTPUT);
  pinMode(PWM_D, OUTPUT);

  t_anterior = millis();
}

// -----------------------------
// LOOP PRINCIPAL
// -----------------------------
void loop() {

  if (millis() - t_anterior >= t_dl) {

    // --------------------------------
    // Cálculo RPM ESQUERDA
    // --------------------------------
    long dE = encoderE - ant_encoderE;
    ant_encoderE = encoderE;

    float rotE = dE / PULSOS_POR_ROT;
    rpmE = rotE * (60000.0 / t_dl);

    // --------------------------------
    // Cálculo RPM DIREITA
    // --------------------------------
    long dD = encoderD - ant_encoderD;
    ant_encoderD = encoderD;

    float rotD = dD / PULSOS_POR_ROT;
    rpmD = rotD * (60000.0 / t_dl);

    // --------------------------------
    // CONTROLE P INDEPENDENTE
    // --------------------------------
    erroE = set_rpmE - rpmE;
    erroD = set_rpmD - rpmD;

    sinalE = Kp * erroE;
    sinalD = Kp * erroD;

    // --------------------------------
    // APLICAÇÃO DO CONTROLE
    // --------------------------------
    acionar_motor((int)sinalE, IN1_E, IN2_E, PWM_E);
    acionar_motor((int)sinalD, IN1_D, IN2_D, PWM_D);

    // --------------------------------
    // DEBUG
    // --------------------------------
    Serial.print("AlvoE:"); Serial.print(set_rpmE);
    Serial.print(" RPM_E:"); Serial.print(rpmE);
    Serial.print(" PWM_E:"); Serial.print(sinalE);

    Serial.print(" | AlvoD:"); Serial.print(set_rpmD);
    Serial.print(" RPM_D:"); Serial.print(rpmD);
    Serial.print(" PWM_D:"); Serial.println(sinalD);

    t_anterior = millis();
  }
}


